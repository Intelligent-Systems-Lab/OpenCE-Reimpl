"""Trajectory data structures for multi-step agent-environment interactions.

This module defines the data structures used to track the complete history
of interactions between the agent (Generator) and the environment during
task execution.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List


@dataclass
class TrajectoryStep:
    """A single step in the agent-environment interaction trajectory.

    Attributes:
        step_index: The sequential step number (1-indexed)
        reasoning: Agent's chain-of-thought reasoning for this step
        bullet_ids: List of playbook bullet IDs referenced by the agent
        code: Python code generated by the agent for this step
        observation: Environment's response after executing the code
    """
    step_index: int
    reasoning: str
    bullet_ids: List[str]
    code: str
    observation: str


@dataclass
class Trajectory:
    """Complete trajectory of agent-environment interactions for a task.

    Attributes:
        steps: List of all trajectory steps in chronological order
        task: The original task instruction
        is_completed: Whether the task was successfully completed
    """
    steps: List[TrajectoryStep]
    task: str
    execution_status: str = "max_steps_reached"

    def format_for_generator(self) -> str:
        """Format trajectory as text for Generator input.

        Returns:
            Multi-line string representation of the trajectory showing
            step-by-step code and observations.
        Example:
            ```
            Step 1:
            Code:
            ```python
            print(apis.api_docs.show_api_doc(app_name='venmo'))
            ```
            Observation:
            Returns a list of transactions...
            Step 2:
            ...
            ```
        """
        lines = []
        for step in self.steps:
            lines.append(f"Step {step.step_index}:")
            lines.append("Code:")
            lines.append("```python")
            lines.append(step.code)
            lines.append("```")
            lines.append("")
            lines.append("Observation:")
            lines.append(step.observation)
            lines.append("")
        return "\n".join(lines)
    
    def format_for_reflector(self) -> str:
        """Format trajectory as text for Reflector analysis.

        Returns:
            Multi-line string representation of the trajectory showing
            step-by-step reasoning, code, and observations.

        Example:
            ```
            Step 1:
            Reasoning: I need to check the Venmo API...
            Bullet IDs: [kb_check_api_schema]
            Code:
            ```python
            print(apis.api_docs.show_api_doc(app_name='venmo'))
            ```

            Observation:
            Returns a list of transactions...

            Step 2:
            ...
            ```
        """
        lines = []
        for step in self.steps:
            lines.append(f"Step {step.step_index}:")
            lines.append(f"Reasoning: {step.reasoning}")
            lines.append(f"Bullet IDs: {step.bullet_ids}")
            lines.append("Code:")
            lines.append("```python")
            lines.append(step.code)
            lines.append("```")
            lines.append("")
            lines.append("Observation:")
            lines.append(step.observation)
            lines.append("")
        return "\n".join(lines)

    def format_final_step(self) -> str:
        """Format the final step of the trajectory.

        Returns:
            Multi-line string representation of the final step showing
            reasoning, bullet IDs, code, and observation.

        Example:
            ```
            Final Step:
            Reasoning: I need to check the Venmo API...
            Bullet IDs: [kb_check_api_schema]
            Code:
            ```python
            print(apis.api_docs.show_api_doc(app_name='venmo'))
            ```

            Observation:
            Returns a list of transactions...
            ```
        """
        if not self.steps:
            return "No steps in trajectory."

        final_step = self.steps[-1]
        lines = []
        lines.append("Final Step:")
        lines.append(f"Reasoning: {final_step.reasoning}")
        lines.append(f"Bullet IDs: {final_step.bullet_ids}")
        lines.append("Code:")
        lines.append("```python")
        lines.append(final_step.code)
        lines.append("```")
        lines.append("")
        lines.append("Observation:")
        lines.append(final_step.observation)
        lines.append("")
        return "\n".join(lines)

    def add_step(
        self,
        reasoning: str,
        bullet_ids: List[str],
        code: str,
        observation: str,
    ) -> None:
        """Add a new step to the trajectory.

        Args:
            reasoning: Agent's reasoning for this step
            bullet_ids: Referenced playbook bullet IDs
            code: Generated code
            observation: Environment's response
        """
        step = TrajectoryStep(
            step_index=len(self.steps) + 1,
            reasoning=reasoning,
            bullet_ids=bullet_ids,
            code=code,
            observation=observation,
        )
        self.steps.append(step)
